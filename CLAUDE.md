# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Sporefront is a hex-based medieval RTS game built with **C# and Unity (URP 2D)**. It was ported from a Swift/SpriteKit project (Grow2). The game logic is fully decoupled from Unity rendering — all engine code is pure C# with no MonoBehaviour dependencies.

## Build & Development

This is a Unity project rooted at `Sporefront/`. Open it in Unity Editor (check `Sporefront/ProjectSettings/ProjectVersion.txt` for the required Unity version). There is no command-line build configured — building and running happens through Unity Editor.

The C# solution file is auto-generated by Unity and excluded from version control via `.gitignore`.

## Architecture

### Core Data Flow

```
Player Input / AI Decision
  → IEngineCommand (Validate → Execute)
    → StateChangeBuilder accumulates mutations
      → StateChangeBatch emitted via OnStateChangesProduced event
        → Visual layer reacts to state changes
```

All game mutations are command-driven. Commands implement `IEngineCommand` (defined in `Engine/EngineCommand.cs`) with two phases: `Validate(GameState)` checks legality, `Execute(GameState, StateChangeBuilder)` mutates state and records changes. Both return `EngineCommandResult` (success/failure).

### GameEngine (Singleton)

`GameEngine.Instance` is the authoritative game state owner. It coordinates six subsystem engines, each updating at different intervals defined in `GameConfig.EngineIntervals`:

| Subsystem | Interval | Purpose |
|-----------|----------|---------|
| MovementEngine | 0.1s | Hex pathfinding and movement |
| CombatEngine | 1.0s | 3-phase combat, stack combat, garrison defense |
| ResourceEngine | 0.5s | Gathering and production |
| ConstructionEngine | 0.5s | Building and upgrades |
| TrainingEngine | 1.0s | Unit training queues |
| VisionEngine | 0.25s | Fog of war |

Subsystems follow the pattern: `Setup(GameState)` for initialization, `Update(double currentTime)` returns `List<StateChange>`.

### State Model

`GameState` is the root container holding all game data via `Dictionary<Guid, T>` lookups:
- `PlayerState` — resources, owned entity IDs, vision sets, research/upgrade progress
- `BuildingData` — type, health, construction/upgrade progress, garrison, training queue
- `ArmyData` — composition (`Dictionary<MilitaryUnitType, int>`), path, combat state, entrenchment
- `VillagerGroupData` — civilian workers for gathering/construction
- `CommanderData` — 5 stats, specialty, rank, stamina, XP

Data classes use **public fields** (not properties). Transient state is marked `[System.NonSerialized]`. All IDs are `Guid`.

### Hex Coordinates

`HexCoordinate` is a struct using **odd-r offset** coordinates (`int q`, `int r`). Key methods: `Distance()`, `Neighbors()`, `CoordinatesWithinRange()`, `CoordinatesInRing()`. Implements `IEquatable<HexCoordinate>` for hash safety.

### State Changes

`StateChange` is the abstract base class. There are ~50 concrete subclasses organized by category (building, army, villager, combat, training, research, garrison). `StateChangeBuilder` accumulates changes, then `Build()` produces a `StateChangeBatch` with timestamp and source command ID.

### AI System

`AIController` manages all AI players via a state machine (`AIState`: Peace → Alert → Defense → Attack → Retreat) with four specialized planners:
- `AIEconomyPlanner` — building placement, villager management, resource gathering
- `AIMilitaryPlanner` — army deployment, target scoring, attacks
- `AIDefensePlanner` — towers, forts, garrison, entrenchment
- `AIResearchPlanner` — technology selection

Each planner returns `List<IEngineCommand>`. AI commands mirror player commands (prefixed with `AI`, e.g., `AIBuildCommand`, `AIMoveCommand`).

`AIGenome` contains 50+ tunable parameters. `EvolutionEngine` runs genetic algorithm optimization using `ArenaSimulator` for headless parallel evaluation on minimal 7x7 maps.

### Visual Layer

Unity-specific code lives in `Scripts/Visual/`. `GameSceneManager` orchestrates the scene. `HexGridRenderer`/`HexTileView`/`HexMeshUtility` handle hex rendering. UI panels (`ActionPanel`, `ArmyDetailPanel`, `BuildingDetailPanel`, etc.) are managed by `UIManager`. The visual layer subscribes to `OnStateChangesProduced` events — it never mutates game state directly.

## Key Conventions

- **Namespaces** follow folder structure: `Sporefront.Engine`, `Sporefront.Data`, `Sporefront.Models`, `Sporefront.AI`, `Sporefront.AI.Commands`, `Sporefront.Visual`
- **Enum extension methods** provide display names, costs, stats (e.g., `BuildingType.MaxLevel()`, `MilitaryUnitType.DisplayName()`)
- **All times** are `double` (seconds). Speed multipliers applied via `gameState.gameSpeed`
- **Defensive iteration**: use `.ToList()` when iterating collections being modified
- **Factory methods** for results: `EngineCommandResult.Success(changes)` / `EngineCommandResult.Failure(reason)`
- **Static configuration** lives in `GameConfig` with nested static classes for intervals, movement, combat, resources, vision, training parameters
- **`[System.Serializable]`** on data classes for Unity serialization compatibility

## Key File Locations

- `Scripts/Engine/GameConfig.cs` — All game balance constants and intervals
- `Scripts/Engine/EngineCommand.cs` — `IEngineCommand` interface and `BaseEngineCommand`
- `Scripts/Data/StateChange.cs` — All ~50 state change types
- `Scripts/Data/GameState.cs` — Root state container
- `Scripts/Models/BuildingType.cs` — Building definitions with costs, levels, requirements
- `Scripts/Models/MilitaryUnit.cs` — Unit stats, damage calc, combat categories
- `Scripts/Models/HexCoordinate.cs` — Hex math (odd-r offset)

All paths relative to `Sporefront/Assets/`.
